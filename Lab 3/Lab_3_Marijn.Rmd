---
title: "Lab 3 Marijn"
author: "Marijn Jaarsma"
date: "2023-12-07"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Libraries, echo=FALSE, warning=FALSE, message=FALSE}
library(geosphere)

```

```{r Q1_Setup}
# Read in data and merge
df_stations <- read.csv("stations.csv", fileEncoding="latin1")
df_temps <- read.csv("temps50k.csv")
df_st <- merge(df_stations, df_temps, by="station_number")

# Define hyper parameters
h_distance <- 4500000
h_date <- 10000
h_time <- 8

# Prediction point
a <- 58.4274
b <- 14.826
date <- "2013-11-04"
times <- c("04:00:00", "06:00:00", "08:00:00", "10:00:00", "12:00:00", "14:00:00", "16:00:00", "18:00:00", "20:00:00", "22:00:00", "24:00:00")
temp <- vector(length=length(times))

```

```{r Q1_Code}
# Remove rows with observations posterior to wanted time
data_dates <- strptime(df_st[, "date"], "%Y-%m-%d", tz="UTC")
wanted_date <- strptime(date, "%Y-%m-%d", tz="UTC")
df_st <- df_st[which(data_times < wanted_time),]

# Distance kernel
k_dist <- exp(-(distHaversine(df_st[, c("longitude", "latitude")], c(a, b))^2) / (2 * h_distance^2))  

plot(distHaversine(df_st[, c("longitude", "latitude")], c(a, b)),
     k_dist,
     xlab="Distance (m)", ylab="Kernel Value (Gaussian)")

# Date kernel
v_date_differences <- as.numeric(as.Date(date, "%Y-%m-%d") - as.Date(df_st[, "date"], "%Y-%m-%d"))
k_date <- exp(-(v_date_differences^2) / (2 * h_date^2))

plot(v_date_differences, k_date,
     xlab="Distance (days)", ylab="Kernel Value (Gaussian)")

# Hour kernel
# https://stackoverflow.com/questions/53818163/calculate-difference-between-hours-not-considering-date
data_hour <- as.numeric(substr(df_st[, "time"], 1, 2))
wanted_hours <- matrix(rep(sapply(times, function(x) {as.numeric(substr(x, 1, 2))}), nrow(df_st)), ncol=length(times), byrow=TRUE)
v_time_differences <- abs(sweep(wanted_hours, 1, data_hour))
k_time <- exp(-(v_time_differences^2) / (2 * h_time^2))

plot(v_time_differences, k_time,
     xlab="Distance (hours)", ylab="Kernel Value (Gaussian)")

# Combined kernel summed
k_comb_sum <- sweep(k_time, 1, k_dist + k_date, FUN="+")

# Non-parametric kernel regression
temp <- colSums(k_comb_sum * df_st$air_temperature) / colSums(k_comb_sum)
plot(temp, type="o", xaxt="n", xlab="Time")
axis(1, at=1:length(temp), labels=times)

```

```{r Q1_Mult_Kernel}
# Combined kernel product
k_comb_prod <- k_dist * k_date * k_time

# Non-parametric kernel regression
temp <- colSums(k_comb_prod * df_st$air_temperature) / colSums(k_comb_prod)
plot(temp, type="o", xaxt="n", xlab="Time")
axis(1, at=1:length(temp), labels=times)

```